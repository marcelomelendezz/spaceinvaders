<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SOMOS · Space Invaders</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    overflow: hidden;
    font-family: 'Courier New', monospace;
  }

  #hud {
    display: flex;
    justify-content: space-between;
    width: 600px;
    max-width: 98vw;
    padding: 6px 10px;
    font-size: 12px;
    color: #00ff41;
    letter-spacing: 2px;
  }

  canvas {
    display: block;
    background: #000;
    border-left: 2px solid #00ff41;
    border-right: 2px solid #00ff41;
  }

  #lives-row {
    display: flex;
    gap: 10px;
    width: 600px;
    max-width: 98vw;
    padding: 4px 10px;
    align-items: center;
  }

  #lives-label {
    font-size: 10px;
    color: #00ff41;
    letter-spacing: 1px;
    margin-right: 4px;
  }
</style>
</head>
<body>

<div id="hud">
  <div>SCORE: <span id="scoreVal" style="color:#fff">0</span></div>
  <div style="color:#fff">SPACE INVADERS</div>
  <div>LEVEL: <span id="levelVal" style="color:#fff">1</span></div>
</div>

<canvas id="c"></canvas>

<div id="lives-row">
  <span id="lives-label">LIVES:</span>
  <div id="livesDisplay"></div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resize() {
  const maxW = Math.min(600, window.innerWidth - 4);
  const maxH = Math.min(520, window.innerHeight - 90);
  canvas.width = maxW;
  canvas.height = maxH;
  document.getElementById('hud').style.width = maxW + 'px';
  document.getElementById('lives-row').style.width = maxW + 'px';
}
resize();
window.addEventListener('resize', resize);

// ── PIXEL ART SPRITES (8x8 grids, 1=color, 0=transparent) ──

// Invader type A (top rows) - classic crab shape
const SPRITE_A = [
  [0,0,1,0,0,0,1,0],
  [0,0,0,1,1,1,0,0],
  [0,1,1,1,1,1,1,0],
  [1,1,0,1,1,0,1,1],
  [1,1,1,1,1,1,1,1],
  [0,1,0,1,1,0,1,0],
  [1,0,0,0,0,0,0,1],
  [0,1,0,0,0,0,1,0],
];
const SPRITE_A2 = [
  [0,0,1,0,0,0,1,0],
  [1,0,0,1,1,1,0,1],
  [1,1,1,1,1,1,1,1],
  [1,1,0,1,1,0,1,1],
  [1,1,1,1,1,1,1,1],
  [0,0,1,0,0,1,0,0],
  [0,1,0,1,1,0,1,0],
  [1,0,1,0,0,1,0,1],
];

// Invader type B (middle rows) - squid shape
const SPRITE_B = [
  [0,0,0,1,1,0,0,0],
  [0,0,1,1,1,1,0,0],
  [0,1,1,1,1,1,1,0],
  [1,1,0,1,1,0,1,1],
  [1,1,1,1,1,1,1,1],
  [0,0,1,0,0,1,0,0],
  [0,1,0,1,1,0,1,0],
  [1,0,1,0,0,1,0,1],
];
const SPRITE_B2 = [
  [0,0,0,1,1,0,0,0],
  [0,0,1,1,1,1,0,0],
  [0,1,1,1,1,1,1,0],
  [1,1,0,1,1,0,1,1],
  [1,1,1,1,1,1,1,1],
  [0,1,0,1,1,0,1,0],
  [1,0,0,0,0,0,0,1],
  [0,1,0,0,0,0,1,0],
];

// Invader type C (bottom rows) - octopus shape
const SPRITE_C = [
  [0,0,1,1,1,1,0,0],
  [0,1,1,1,1,1,1,0],
  [1,1,1,1,1,1,1,1],
  [1,1,0,1,1,0,1,1],
  [1,1,1,1,1,1,1,1],
  [0,0,0,1,1,0,0,0],
  [0,0,1,0,0,1,0,0],
  [0,1,0,0,0,0,1,0],
];
const SPRITE_C2 = [
  [0,0,1,1,1,1,0,0],
  [0,1,1,1,1,1,1,0],
  [1,1,1,1,1,1,1,1],
  [1,1,0,1,1,0,1,1],
  [1,1,1,1,1,1,1,1],
  [0,1,0,1,1,0,1,0],
  [1,0,1,0,0,1,0,1],
  [0,0,1,0,0,1,0,0],
];

// Player ship sprite (16x8)
const SPRITE_PLAYER = [
  [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1],
  [1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1],
];

function drawSprite(sprite, x, y, scale, color) {
  ctx.fillStyle = color;
  for (let row = 0; row < sprite.length; row++) {
    for (let col = 0; col < sprite[row].length; col++) {
      if (sprite[row][col]) {
        ctx.fillRect(
          Math.floor(x + col * scale),
          Math.floor(y + row * scale),
          scale, scale
        );
      }
    }
  }
}

// ── STATE ──────────────────────────────────────────────────
let score = 0, lives = 3, level = 1;
let running = false, gameOver = false, gameStarted = false;
let player, bullets, invaders, enemyBullets, particles;
let invDir = 1, invSpeedX = 1;
let shootTimer = 0, frameCount = 0;
let animFrame = 0, animTimer = 0;
let keys = {};
let raf;

const SCALE = 3; // pixel size
const INV_W = 8 * SCALE;
const INV_H = 8 * SCALE;
const INV_PADX = 16;
const INV_PADY = 14;

// Invader colors by row type
const INV_COLORS = ['#ff6b6b', '#ff6b6b', '#ffdd57', '#ffdd57', '#00d4ff', '#00d4ff'];

function getSprites(rowType) {
  if (rowType === 0) return [SPRITE_A, SPRITE_A2];
  if (rowType === 1) return [SPRITE_B, SPRITE_B2];
  return [SPRITE_C, SPRITE_C2];
}

function init() {
  score = 0; lives = 3; level = 1; gameOver = false;
  document.getElementById('scoreVal').textContent = 0;
  document.getElementById('levelVal').textContent = 1;
  updateLives();
  initLevel();
}

function initLevel() {
  const W = canvas.width, H = canvas.height;

  player = {
    x: W / 2 - 8 * SCALE / 2,
    y: H - 40,
    w: 16 * SCALE,
    h: 8 * SCALE,
    speed: 3 + level * 0.2,
    cooldown: 0
  };

  bullets = [];
  enemyBullets = [];
  particles = [];
  invaders = [];
  animFrame = 0;
  animTimer = 0;

  const cols = 11;
  const rows = Math.min(5 + Math.floor(level / 2), 6);
  const totalW = cols * (INV_W + INV_PADX) - INV_PADX;
  const startX = (W - totalW) / 2;

  for (let r = 0; r < rows; r++) {
    const rowType = r < 1 ? 0 : r < 3 ? 1 : 2;
    for (let c = 0; c < cols; c++) {
      invaders.push({
        x: startX + c * (INV_W + INV_PADX),
        y: 28 + r * (INV_H + INV_PADY),
        w: INV_W, h: INV_H,
        rowType,
        alive: true,
        col: c, row: r
      });
    }
  }

  invDir = 1;
  invSpeedX = 0.5 + level * 0.1;
  shootTimer = 60;
  frameCount = 0;

  updateLives();
}

function updateLives() {
  const d = document.getElementById('livesDisplay');
  d.innerHTML = '';
  for (let i = 0; i < lives; i++) {
    const mini = document.createElement('canvas');
    mini.width = 16 * 2;
    mini.height = 8 * 2;
    mini.style.imageRendering = 'pixelated';
    const mc = mini.getContext('2d');
    mc.fillStyle = '#00ff41';
    for (let row = 0; row < SPRITE_PLAYER.length; row++) {
      for (let col = 0; col < SPRITE_PLAYER[row].length; col++) {
        if (SPRITE_PLAYER[row][col]) mc.fillRect(col * 2, row * 2, 2, 2);
      }
    }
    d.appendChild(mini);
  }
}

// ── INPUT ──────────────────────────────────────────────────
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Space') {
    e.preventDefault();
    if (!gameStarted) { gameStarted = true; running = true; startLoop(); return; }
    if (gameOver) { init(); gameStarted = true; running = true; startLoop(); return; }
    shoot();
  }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

// Touch
let touchX = null;
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  touchX = e.touches[0].clientX;
  if (!gameStarted) { gameStarted = true; running = true; startLoop(); return; }
  if (gameOver) { init(); gameStarted = true; running = true; startLoop(); return; }
  shoot();
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (touchX === null) return;
  const dx = e.touches[0].clientX - touchX;
  player.x += dx * 1.2;
  player.x = Math.max(0, Math.min(canvas.width - player.w, player.x));
  touchX = e.touches[0].clientX;
}, { passive: false });

canvas.addEventListener('touchend', () => { touchX = null; });

// ── LOOP ───────────────────────────────────────────────────
function startLoop() {
  if (raf) cancelAnimationFrame(raf);
  loop();
}

function loop() {
  if (!running) return;
  raf = requestAnimationFrame(loop);
  update();
  draw();
}

// ── UPDATE ─────────────────────────────────────────────────
function update() {
  frameCount++;

  // Animate invaders
  animTimer++;
  if (animTimer >= 30) { animTimer = 0; animFrame = 1 - animFrame; }

  const W = canvas.width, H = canvas.height;

  // Player move
  if (keys['ArrowLeft'] || keys['KeyA']) player.x -= player.speed;
  if (keys['ArrowRight'] || keys['KeyD']) player.x += player.speed;
  player.x = Math.max(0, Math.min(W - player.w, player.x));
  if (player.cooldown > 0) player.cooldown--;

  // Player bullets
  bullets = bullets.filter(b => b.y > -10);
  bullets.forEach(b => b.y -= 10);

  // Invader move
  const alive = invaders.filter(i => i.alive);
  if (alive.length === 0) { level++; document.getElementById('levelVal').textContent = level; initLevel(); return; }

  let hitWall = false;
  alive.forEach(inv => {
    inv.x += invDir * invSpeedX;
  });

  const leftmost = Math.min(...alive.map(i => i.x));
  const rightmost = Math.max(...alive.map(i => i.x + i.w));
  if (rightmost >= W - 2 || leftmost <= 2) {
    hitWall = true;
  }

  if (hitWall) {
    invDir *= -1;
    alive.forEach(inv => { inv.y += 16; });
    invSpeedX = Math.min(invSpeedX + 0.05, 5);
  }

  // Invaders reach player line
  if (alive.some(inv => inv.y + inv.h >= player.y)) {
    loseLife();
    return;
  }

  // Enemy shoot
  shootTimer--;
  if (shootTimer <= 0) {
    shootTimer = Math.max(20, 70 - level * 5 - (55 - alive.length));
    // Only bottom-most in each column shoots
    const cols = {};
    alive.forEach(inv => {
      if (!cols[inv.col] || inv.y > cols[inv.col].y) cols[inv.col] = inv;
    });
    const shooters = Object.values(cols);
    if (shooters.length > 0) {
      const s = shooters[Math.floor(Math.random() * shooters.length)];
      enemyBullets.push({ x: s.x + s.w / 2, y: s.y + s.h, speed: 4 + level * 0.4, phase: 0 });
    }
  }

  // Enemy bullets
  enemyBullets = enemyBullets.filter(b => b.y < H + 10);
  enemyBullets.forEach(b => { b.y += b.speed; b.phase += 0.3; });

  // Bullet vs invader
  for (let bi = bullets.length - 1; bi >= 0; bi--) {
    const b = bullets[bi];
    for (let ii = 0; ii < invaders.length; ii++) {
      const inv = invaders[ii];
      if (!inv.alive) continue;
      if (b.x >= inv.x && b.x <= inv.x + inv.w && b.y >= inv.y && b.y <= inv.y + inv.h) {
        inv.alive = false;
        bullets.splice(bi, 1);
        score += (level === 1 ? (inv.rowType === 0 ? 30 : inv.rowType === 1 ? 20 : 10) : 10 * level);
        document.getElementById('scoreVal').textContent = score;
        spawnExplosion(inv.x + inv.w / 2, inv.y + inv.h / 2, INV_COLORS[inv.row]);
        break;
      }
    }
  }

  // Enemy bullet vs player
  for (let bi = enemyBullets.length - 1; bi >= 0; bi--) {
    const b = enemyBullets[bi];
    if (b.x >= player.x && b.x <= player.x + player.w &&
        b.y >= player.y && b.y <= player.y + player.h) {
      enemyBullets.splice(bi, 1);
      loseLife();
      return;
    }
  }

  // Particles
  particles = particles.filter(p => p.life > 0);
  particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; });
}

function shoot() {
  if (player.cooldown > 0) return;
  bullets.push({ x: player.x + player.w / 2, y: player.y });
  player.cooldown = 18;
}

function spawnExplosion(x, y, color) {
  for (let i = 0; i < 12; i++) {
    const angle = (Math.PI * 2 * i) / 12;
    const speed = 1 + Math.random() * 2;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 18 + Math.floor(Math.random() * 12),
      color,
      size: 2 + Math.floor(Math.random() * 3)
    });
  }
}

function loseLife() {
  lives--;
  updateLives();
  if (lives <= 0) {
    running = false;
    gameOver = true;
    drawGameOver();
  } else {
    bullets = [];
    enemyBullets = [];
    player.x = canvas.width / 2 - player.w / 2;
  }
}

// ── DRAW ───────────────────────────────────────────────────
function draw() {
  const W = canvas.width, H = canvas.height;
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);

  // Stars
  ctx.fillStyle = '#fff';
  for (let i = 0; i < 80; i++) {
    const sx = (i * 173 + 7) % W;
    const sy = (i * 113 + 19) % H;
    const bright = i % 4 === 0;
    ctx.globalAlpha = bright ? 0.9 : 0.4;
    ctx.fillRect(sx, sy, bright ? 2 : 1, bright ? 2 : 1);
  }
  ctx.globalAlpha = 1;

  // Invaders
  const alive = invaders.filter(i => i.alive);
  alive.forEach(inv => {
    const [s1, s2] = getSprites(inv.rowType);
    const sprite = animFrame === 0 ? s1 : s2;
    const color = INV_COLORS[Math.min(inv.row, INV_COLORS.length - 1)];
    drawSprite(sprite, inv.x, inv.y, SCALE, color);
  });

  // Player
  drawSprite(SPRITE_PLAYER, player.x, player.y, SCALE, '#00ff41');

  // Player bullets
  ctx.fillStyle = '#00ff41';
  ctx.shadowColor = '#00ff41';
  ctx.shadowBlur = 6;
  bullets.forEach(b => {
    ctx.fillRect(b.x - 2, b.y, 4, 12);
  });
  ctx.shadowBlur = 0;

  // Enemy bullets (zigzag)
  ctx.fillStyle = '#ff4444';
  ctx.shadowColor = '#ff4444';
  ctx.shadowBlur = 4;
  enemyBullets.forEach(b => {
    const xOff = Math.sin(b.phase) * 3;
    ctx.fillRect(b.x + xOff - 2, b.y, 4, 8);
  });
  ctx.shadowBlur = 0;

  // Particles
  particles.forEach(p => {
    ctx.fillStyle = p.color;
    ctx.globalAlpha = p.life / 30;
    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
  });
  ctx.globalAlpha = 1;

  // Bottom line
  ctx.fillStyle = '#00ff41';
  ctx.fillRect(0, H - 20, W, 2);

  // Start screen
  if (!gameStarted && !gameOver) {
    drawOverlay('SPACE INVADERS', 'PRESS SPACE TO START', '#00ff41');
  }

  if (gameOver) drawGameOver();
}

function drawOverlay(title, sub, color) {
  const W = canvas.width, H = canvas.height;
  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = color;
  ctx.font = `bold ${Math.floor(W / 18)}px 'Courier New'`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(title, W/2, H/2 - 30);
  ctx.fillStyle = '#fff';
  ctx.font = `${Math.floor(W / 36)}px 'Courier New'`;
  ctx.fillText(sub, W/2, H/2 + 20);

  // Blink
  if (Math.floor(Date.now() / 500) % 2 === 0) {
    ctx.fillStyle = '#ffdd57';
    ctx.font = `${Math.floor(W / 42)}px 'Courier New'`;
    ctx.fillText('ARROWS = MOVE   SPACE = FIRE', W/2, H/2 + 55);
  }
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';
}

function drawGameOver() {
  const W = canvas.width, H = canvas.height;
  ctx.fillStyle = 'rgba(0,0,0,0.82)';
  ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = '#ff4444';
  ctx.font = `bold ${Math.floor(W / 16)}px 'Courier New'`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('GAME OVER', W/2, H/2 - 40);
  ctx.fillStyle = '#fff';
  ctx.font = `${Math.floor(W / 30)}px 'Courier New'`;
  ctx.fillText(`SCORE: ${score}`, W/2, H/2 + 5);
  ctx.fillText(`LEVEL: ${level}`, W/2, H/2 + 35);
  if (Math.floor(Date.now() / 500) % 2 === 0) {
    ctx.fillStyle = '#ffdd57';
    ctx.font = `${Math.floor(W / 40)}px 'Courier New'`;
    ctx.fillText('PRESS SPACE TO PLAY AGAIN', W/2, H/2 + 72);
  }
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';

  // Keep redrawing for blink effect
  if (gameOver) requestAnimationFrame(() => { if (gameOver) { draw(); } });
}

// Init
init();
draw();
</script>
</body>
</html>
